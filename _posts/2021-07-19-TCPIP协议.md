---

layout:     post   				    # 使用的布局（不需要改）
title: 	TCP/IP协议		# 标题 
date:       2021-07-19				# 时间
author:     t298						# 作者
header-img: img/wallhaven-j38xpq.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签

   - 基础
   - 网络

---

## 什么是TCP/IP协议

顾名思义 TCP/IP(Transmission Control Protocol/Internet Protocol),**传输控制协议/网际协议**,TCP/IP是现代Internet的核心技术。所有的系统、终端、线路、用户、开发者，都必须遵守TCP/IP协议族所规定的法则！IP世界的根本法就是TCP/IP协议族。其中还包括HTTP、Telnet、FTP、RIP、UDP等等。其名字来源于其中最主要的两个协议-------TCP与IP。它们分别在TCP/IP模型的第二层与第三层。



## 五层模型

应用层，传输层，网络层，数据链路层， 物理层。

1. **物理层**:我们的每一台电脑都必须通过一定的介质相连才能交互吧，那我们使用的光迁，电缆就是将计算机连同的物理介质.那么这就是物理层。通过这些光纤，可以传输0， 1这样的高底电平达到数据的传输。

2. **数据链路层：**在已经有了物理传输介质之后，我们需要关注的是，数据应该以那种形式传输。如果仅仅时传输单纯的01这样的串是没有任何意义的。 在链路层据定义了多少电信号为一组，这**一组电信号构成了一个数据包**，称之为**帧。**一个帧分为head以及data两个部分，head中存储了一系列的参数MAC地址就是其一，data存储了计算机之间交互的数据。

   以太网协议规定，连入网络的每一个计算机都会有网卡接口，每一个网卡都会有一个唯一的地址，这个地址就叫做 **MAC 地址**。计算机之间的数据传送，就是通过 MAC 地址来唯一寻找、传送的。如此以来相同子网中的计算机就可以通过广播的方式进行数据的准确传输.

3. **网络层：**对与相同子网的计算机可以数据交互之后，对与不同子网的计算机我们应该怎么办呢。在网络层引入了三个协议：IP协议，ARP协议，路由协议。

   - **IP协议：**IP协议制作了一套新的地质，长4个字节，它的范围：0.0.0.0～255.255.255.255，而且时分为两个部分：网络部分 + 主机部分，这两个部分的长度根据**子网掩码**决定。例如前24位时网络号，后8位为主机号。

     

   - **ARP协议：**即地址解析协议，是根据**IP地址**获取**MAC地址**的一个网络层协议。其工作原理如下：

     ARP首先会发起一个请求数据包，数据包的首部包含了目标主机的IP地址，然后这个数据包会在链路层进行再次包装，生成**以太网数据包，**最终由以太网广播给子网内的所有主机，每一台主机都会接收到这个数据包，并取出标头里的IP地址，然后和自己的IP地址进行比较，如果相同就返回自己的MAC地址，如果不同就丢弃该数据包。ARP接收返回消息，以此确定目标机的MAC地址；与此同时，ARP还会将返回的MAC地址与对应的IP地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。

   

   - **路由协议**：简单理解就是不同子网与子网间的通行必须通过网关的多次转发，最终找到目标IP所在的子网。

   

4. **传输层**：我们已经实现了互联网中两台计算机的数据传输交互。其实初每个数据包是由确定的应用程序发出，假设计算机A的程序QQ 发给计算机B的程序QQ。当数据包到达B的时候，B可能已经运行了很多程序，那么怎么来确定那个程序是目标程序呢-->使用端口号，每个应用程序都是有自己默认的端口号的，传输层解析其端口号找到对应程序。

   

5. **应用层：** 我么需要注意常见的有 HTTP、FTP、SMTP 等，HTTP 是一种比较常用的应用层协议，主要用于B/S架构之间的数据通信。服务端收到请求以后，就能正确的解析客户端发来的数据，当请求处理完以后，再按照客户端要求的格式返回，客户端收到结果后，按照服务端返回的格式进行解析。

   所以应用层的主要工作就是**定义数据格式并按照对应的格式解读数据。**

## 三次握手

![preview](https://raw.githubusercontent.com/t298/Figure-bed/master/img/tcp-ip.jpg)

第一次握手:Client(主机A)想Server(主机B)发送一个连接请求,在这个包中标志位SYN=1,发送序号SEQ=x,上图中令x=200,Client进入SYN_SEND状态,等待Server确认。

第二次握手:Server收到数据包后由标志位SYN=1知道Client请求建立连接,Server将标志位SYN和ACK都置为1,确认序号ACK=x+1=201,随机阐释一个发送序号y,令y=500。并将该数据包发送给Client以确认连接请求,Server进入SYN_RCVD状态。

第三次握手:Client收到去人后,检查确认序号ACK是否为x+1=201;标志位ACK是否为1,如果正确,则将标志位ACK置1,确认序号ACK=y+1=501,并将该数据包发送给Server,Server检查确认需号ACK是否为y+1=501,标志位是否为1,如果正确则 连接建立成功,Client和Server进入ESTABLISHED状态。

## 四次挥手

![](https://raw.githubusercontent.com/t298/Figure-bed/master/img/%E6%96%ADtcp-ip.jpg)

第一次挥手:当客户端A要断开TCP连接时,发送一个包,其中标志位FIN=1,ACK=1,发送序号SEQ=X,确认序号ACK=Z,Client进入FIN_WAIT状态。

第二次挥手:客户B知道A要断开后,发送一个确认包,其中标志位ACK=1,发送序号SEQ=Z确认序号ACK=x+1,Server进入CLOSE_WAIT状态。

第三次挥手:客户B也断开TCP连接,此时发送一个包,其中,标志位FIN=1,发送序号SEQ=Z+1,Server进入LAST_ACK状态。

第四次挥手:客户A收到B的断开请求后,Client进入TIME_WAIT状态,接着发送一个确认包,标志位ACK=1,发送序号SEQ=x+1,确认序号ACK=Z+2,Server进入CLOSE状态。

## TCP报文格式

![](https://raw.githubusercontent.com/t298/Figure-bed/master/img/tcp%E6%8A%A5%E6%96%87.jpg)

1. 源端口号和目的端口字段-----各占16bit。

2. 序号字段-----SEQ序号,占32bit。TCP连接中传送的的数据流中的每一个字节都编上序号，序号字段的值则是本报文段所发送的数据的第一个字节的序号。

3. 确认序号-----ACK序号,32bit，是期望收到对方的写下一个报文段的数据的第一个字节的序号。只有ACK的标志位为1是，确认序号字段才有效，ACK=SEQ+1。

4. 标志位:有6个如下

   URG-----紧急信号表明紧急指针(urgent pointer),它能告诉系统此报文段有紧急数据,应尽快传送。

   ACK-----确认信号只有当ACK=1时确认号字段才有效。当ACK=0时,确认号无效。

   PSH-----推送信号接收TCP推送bit置1的报文段，则尽快交付给接收应用进程，无需缓存。

   RST-----复位信号当RST=1时,表明TCP连接中有严重错误，则释放连接，然后再重新建立连接。

   SYN-----同步信号SYN表示一个连接请求或连接接收报文。

   FIN-----终止信号用来释放一个连接。当FIN=1,表明报文段的发送端的数据已发送完毕,要求释放运输连接。

5. 数据偏移-----占4bit,它自出报文段的数据起始处距离TCP报文段起始处的位置。

6. 窗口字段-----占16bit,用来控制对方发送的数据量,单位为字节。TCP连接的一端根据设置的缓存空间大小确定自己的接收窗口大小,然后通知对方确定对方的发送窗口上限。

7. 检验和-----占16bit,检验报文段的首部和数据,在检验之前要加上12字节的伪首部。

8. 紧急指针字段-----16bit。紧急指针指出在本报文段的紧急数据的最后一个字节的序号。

9. 选项字段-----无固定长度,TCP只规定了一种选项最大报文段长度MSS。

10. 保留字段-----占6位,暂无。
