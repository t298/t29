---
layout:     post
title:      什么是jvm？
subtitle:   初步了解jvm
date:       2020-05-20
author:     t298
header-img: img/ 壁纸165@2x.jpg
catalog: 	 true
tags:
    - java
    - 面试
---
#### 什么是jvm?

- jvm是"java virtual machine"(java虚拟机)的缩写，它是虚构出来的计算机，是通过在物理机上仿真模拟各种计算机功能来实现的。
- 由于jvm屏蔽了与操作系统平台相关的信息，使的java语言只需要生成在jvm上运行的字节码，就可以实现"一次编译，处处运行"

#### jvm的组成？

主要分为五大模块：类装载器子系统，运行时数据区，执行引擎，本地方法接口，垃圾收集模块。

1. 类装载器子系统：用于装载 .class文件
2. 运行时数据区：方法区，堆，java栈，pc寄存器，本地方法栈。
3. 执行引擎：用于执行字节码或者本地方法。
4. 本地方法接口
5. 垃圾收集模块

- 程序在执行前需要把java源代码转换成字节码文件，jvm在通过**类加载器**把文件加载到内存中，也就是**运行时数据区**，而字节码文件是jvm的一套指令集规范，并不能直接与底层操作系统直接去交互，因此需要特定的命令解析器，也就是**执行引擎**将字节码翻译成底层指令在交给cpu去执行，而这个过程需要调用其它语言的接口，也就是**本地库接口**，来实现整个功能。

#### java运行时数据区域

java虚拟机在执行java程序中会把内存区域划分成若干个区域。



1. **程序计数器**（Program Counter Register）

- 内存私有

程序计数器占用较小的内存空间，可以看成当前线程所执行的字节码的行号指示器。由于虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定时刻，一个处理器都只会执行一条线程中的指令，因此为了线程先换后能够回复到正确的执行位置，每条线程都需要一个独立的程序计数器。



如果线程正在执行java中的方法，程序记录器记录的就是正在执行虚拟机字节码指令的地址，如果是Native方法，这个计数器就为空。**因此该内存区域是唯一一个在java虚拟机规范中没有规定OutofMemoryError（内存不足）的区域。**



2. **java虚拟机栈**（Java Virtual Machine Stacks）

- 内存私有，生命周期和线程相同
- 异常规定：StackOverflowError、OutOfMemoryError

java虚拟机栈描述的是java方法执行的内存模型，每个方法在执行的同时都会出恩改建一个线帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。





3. **本地方法栈**（Native Method Stack）

- 内存私有，生命周期和线程相同
- 异常规定：StackOverflowError、OutOfMemoryError

本地方法栈与虚拟机的作用是一样的，只不过虚拟机栈是服务java方法的，而本地方法栈是为虚拟机调用Native方法服务到的。



4. **java堆**（Java Heap）

- 内存共享
- 异常规定：OutofMemoryError

java堆是java虚拟机中内存最大的一块，是被所有线程共享的，在虚拟机启动的时候创建，java堆存在的唯一目的就是存放对象实例，**几乎**所有的对象都是在这里分配内存的。

java堆是垃圾收集管理的主要区域，因此java堆常被称为“GC堆”，由于现在收集器基于分代收集算法，java堆还可以细分：**“新生代”和“老年代”**

根据java虚拟机规范的规定，java堆可以处于物理上不连续的内存控件中，只要逻辑上是连续的即可。



5. **方法区**（Methed Area）

- 内存共享
- 异常规定：OutOfMemoryError
- **方法区不等于永生代**

方法区用于存储已经被虚拟机加载的类信息，常量，静态变量，及时编译器编译后的代码等数据。java虚拟机对方法取的限制非常宽松，除了和java堆一样不需要连续的内存和选择固定大小和可拓展外，还可以选择不实现垃圾收集。





#### 运行时常量池

运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池用于存放编译期生成的各种字面量和符号引用，这部分在类加载后进入方法区的运行是常量池中，如String类的intern()方法。




