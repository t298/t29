---
layout:     post   				    # 使用的布局（不需要改）
title: 计算机中的浮点数的精度			# 标题 
subtitle:   #副标题
date:       2022-08-24		# 时间
author:     t298						# 作者
header-img: img/吃糖少女.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - java
---

### 为什么12-11.9等于0.10000038？

```java
float a = 12.0f;
float b = 11.9f;

System.out.println(a-b);
 // 0.10000038
```

之所以存在上面这个问题是因为计算机使用的是二进制。

### 小数的二进制表示问题

11转换为二进制是1011，我们可以把任何一个整数用二进制精准的表示出来。

但是对于小数不可以，小数如何转换为二进制呢，用乘法，乘到没有小数为止。

举例：0.9表示为小数，首先是

​		0.9 * 2 = 1.8 取整数部分 1

​		0.8 * 2 = 1.6 取整数部分 1

​		0.6 * 2 = 1.2 取整数部分 1

这个循环会一直存在下去，1100100100100...... 

### float型在内存中的存储

java的float在内存中占4个字节，

0-22位：尾数部分

23-29位：指数部分，用于存储科学计数法中的指数数据，并且采用移位存储

30-31位：符号位，0代表正，1代表为负

### 将一个float型转化为内存存储格式

1. 先将这个实数的绝对值化为二进制格式。
2. 将这个二进制格式实数的小数点左移或右移n位，直到小数点移动到第一个有效数字的右边。
3. 从小数点右边第一位开始数出二十三位数字放入第22到第0位。
4. 如果实数是正的，则在第31位放入“0”，否则放入“1”。
5. 如果n 是左移得到的，说明指数是正的，第30位放入“1”。如果n是右移得到的或n=0，则第30位放入“0”。
6. 如果n是左移得到的，则将n减去1后化为二进制，并在左边加“0”补足七位，放入第29到第23位。如果n是右移得到的或n=0，则将n化为二进制后在左边加“0”补足七位，再各位求反，再放入第29到第23位

举例：11.9的内存格式

1. 将11.9化为二进制后大约是” 1011. 1110011001100110011001100…”。
2. 将小数点左移三位到第一个有效位右侧： “1. 011 11100110011001100110 “。 保证有效位数24位，右侧多余的截取（误差在这里产生了 ）。
3. 这已经有了二十四位有效数字，将最左边一位“1”去掉，得到“ 011 11100110011001100110 ”共23bit。将它放入float存储结构的第22到第0位。
4. 因为11.9是正数，因此在第31位实数符号位放入“0”。
5.  由于我们把小数点左移，因此在第30位指数符号位放入“1”。
6.  因为我们是把小数点左移3位，因此将3减去1得2，化为二进制，并补足7位得到0000010，放入第29到第23位。
   最后表示11.9为： 0 1 0000010 011 11100110011001100110

### 将内存格式的float转换十进制

1. 将第22位到第0位的二进制数写出来，在最左边补一位“1”，得到二十四位有效数字。将小数点点在最左边那个“1”的右边。
2. 取出第29到第23位所表示的值n。当30位是“0”时将n各位求反。当30位是“1”时将n增1。
3. 将小数点左移n位（当30位是“0”时）或右移n位（当30位是“1”时），得到一个二进制表示的实数。
4. 将这个二进制实数化为十进制，并根据第31位是“0”还是“1”加上正号或负号即可。

### 计算12.0-11.9

1.  操作数的检查
   - 如果判断两个需要加减的浮点数有一个为0，即可得知运算结果而没有必要再进行有序的一些列操作。
2. 比较阶码（指数位）大小并完成对阶
   - 两浮点数进行加减，首先要看两数的 指数位 是否相同，即小数点位置是否对齐。若两数 指数位 相同，表示小数点是对齐的，就可以进行尾数的加减运算。反之，若两数阶码不同，表示小数点位置没有对齐，此时必须使两数的阶码相同，这个过程叫做对阶 。
     如何对阶(假设两浮点数的指数位为 Ex 和 Ey )：通过尾数的移位以改变 Ex 或 Ey ，使之相等。由于浮点表示的数多是规格化的，尾数左移会引起最高有位的丢失，造成很大误差；而尾数右移虽引起最低有效位的丢失，但造成的误差较小，因此，对阶操作规定使尾数右移，尾数右移后使阶码作相应增加，其数值保持不变。很显然，一个增加后的阶码与另一个相等，所增加的阶码一定是小阶。因此在对阶时，总是使小阶向大阶看齐 ，即小阶的尾数向右移位 ( 相当于小数点左移 ) ，每右移一位，其阶码加 1 ，直到两数的阶码相等为止，右移的位数等于阶差 △ E 。
3.  尾数（有效数位）进行加或减运算
   - 对阶完毕后就可 有效数位 求和。不论是加法运算还是减法运算，都按加法进行操作，其方法与定点加减运算完全一样。

12.0f 的内存存储格式为: 0 1 0000010  100 0000000000 0000000000

11.9f 的内存存储格式为: 0 1 0000010  011 1110011001 1001100110

12.0-11.9 结果： 0 1 0000010 00000011001100110011010
将结果还原为十进制为： 0.000 11001100110011010= 0.10000038

### 不推荐直接对浮点数进行计算

可以将小数转换为整数来进行计算或者使用"BigDecimal",本质是对一个整形数组的计算。



























